% $Author: oscar $
% $Date: 2007-09-23 11:56:47 +0200 (dim, 23 sep 2007) $
% $Revision: 12130 $
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6in,9in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	\renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{Les classes de base}
\label{cha:basic}
Une grande partie de la magie de Smalltalk ne réside pas dans son langage mais dans ses bibliothèques de classes. Pour programmer efficacement en Smalltalk, vous devez apprendre comment les bibliothèques de classes servent le langage et l'environnement. Les bibliothèques de classes sont entièrement écrites en Smalltalk et peuvent facilement être étendues, puisqu'un paquet peut ajouter une nouvelle fonctionnalité à une classe même s'il ne définit pas cette classe. 

Notre but ici n'est pas de présenter en détail l'intégralité des bibliothèques de classes de Squeak, mais plutôt d'indiquer quelles classes et méthodes clés vous devrez utiliser ou surcharger pour programmer efficacement. Ce chapitre couvre les classes de base qui vous seront utiles dans la plupart de vos applications: \ct{Object}, \ct{Number} et ses sous-classes, \ct{Character}, \ct{String}, \ct{Symbol} et \ct{Boolean}.

\md{Here are some comments:\\
- copying: Good question... the copying in Squeak is much too complicated... there is for one the "old" smalltalk way of
  overrifing postCopy, and then the "automatic" deepCopy... which is quite complex and (I think) was no good idea...
 (see class comment in  DeepCopier)\\
- Debugging: Yes, needs its own chapter. We should talk about haltIf, haltOnce...\\
- assert: Object>>>assert: can take both a block and a boolean, because boleen implements \#value.
  (I will fix SUnit to allow both, too).\\
- Characters and Strings: we should talk about Unicode stuff... but I don't know too much myself.}

%=================================================================
\section{Object}

Dans tous les cas, \clsindmain{Object} est la racine de la hiérarchie d'héritage. En réalité, dans \squeak, la vraie racine de la hiérarchie est \clsind{ProtoObject} qui est utilisée pour définir les entités minimales qui se font passer pour des objets, mais nous pouvons ignorer ce point pour l'instant.
% (more on this later in the chapter on reflection).

\ct{Object} peut être trouvée dans la catégorie \scatind{Kernel-Objects}. Étonnamment, on y trouve plus de 400 méthodes (avec les extensions). En d'autres termes, toutes les classes que vous définirez seront automatiquement munies de ces 400 méthodes, que vous sachiez ce qu'elles font ou non. Notez que certaines de ces méthodes pourraient être supprimées et que dans les nouvelles versions de \squeak certaines méthodes superflues devraient l'être.

\sd{I do not like to quote something that can change and that people can find simply in the image but let us keep it for now.}
Le commentaire de la classe \ct{Object} indique:
\needlines{4}
\begin{quote}
\textit{\ct{Object} est la classe racine de la plupart des autres classes dans la hiérarchie des classes. Les exceptions sont \ct{ProtoObject} (super-classe de \ct{Object}) et ses sous-classes.
La classe \ct{Object} fournit le comportement par défaut, commun à tous les objets classiques, comme l'accès, la copie, la comparaison, le traitement des erreurs, l'envoi de messages, et la \ind{réflexion}. Les messages utiles auxquels tous les objets devraient répondre sont également définis ici.
\ct{Object} n'a pas de variable d'instance, aucune ne devrait être créée. Ceci est dû aux nombreuses classes d'objets qui héritent de \ct{Object}, qui ont des implémentations particulières (\ct{SmallInteger} et \ct{UndefinedObject} par exemple) ou à certaines classes standard que la VM connaît et pour laquelle leur structure et leur organisation est importante.}
\end{quote}

Si nous naviguons dans les catégories des méthodes d'instance de \ct{Object}, nous commençons à voir quelques uns des comportements clé qu'elle apporte.

%-----------------------------------------------------------------
\subsection{Impression}
Tout objet en Smalltalk peut renvoyer une forme imprimée de lui-même. Vous pouvez sélectionner n'importe quelle expression dans un workspace et sélectionner le menu \menu{print it}: ceci exécute l'expression et demande à l'objet renvoyé de s'imprimer. En réalité le message \ct{printString} est envoyé à l'objet retourné. La méthode \mthind{Object}{printString}, qui est une \ind{méthode générique}, envoie le message \mthind{Object}{printOn:} à son receveur. Le message \ct{printOn:} est un point d'entrée qui peut être spécialisé. 

\ct{Object>>>printOn:} est une des méthodes que vous surchargerez le plus souvent. Cette méthode prend comme argument un flôt  (\clsind{Stream}) dans lequel une représentation en chaîne de caractères (\clsind{String}) de l'objet sera écrite. L'implémentation par défaut écrit simplement le nom de la classe précédée par ``\ct{a}'' ou ``\ct{an}''. \ct{Object>>>printString} retourne la chaîne de caractères (\ct{String}) écrite:

Par exemple, la classe \clsind{Browser} ne redéfinit pas le méthode \ct{printOn:} et envoyer le message \ct{printString} à une instance exécute la méthode définie dans \ct{Object}. 
\begin{code}{@TEST}
Browser new printString --> 'a Browser'
\end{code}

La classe \ct{TTCFont} montre un exemple de spécialisation de \mthind{TTCFont}{printOn:}. Elle imprime le nom de la classe suivie par le nom de la famille, la taille et le nom de la sous-famille de la police, comme le montre le code ci-dessous qui imprime une instance de cette classe.

% \needlines{7}
\begin{method}[zork]{printOn: redéfinition.}
TTCFont>>>printOn: aStream
        aStream nextPutAll: 'TTCFont(';
		nextPutAll: self familyName; space;
		print: self pointSize; space;
		nextPutAll: self subfamilyName;
		nextPut: $)
\end{method}\ignoredollar$

\begin{code}{@TEST}
TTCFont allInstances anyOne printString --> 'TTCFont(BitstreamVeraSans 6 Bold)'
\end{code}

Notez que le message \ct{printOn:} n'est pas le même que \mthind{Object}{storeOn:}. Le message \ct{storeOn:} ajoute au flôt passé en argument une expression pouvant être utilisée pour recréer le receveur. Cette expression est évaluée quand le flôt est lu avec le message \ct{readFrom:}. \ct{printOn:} retourne simplement une version textuelle du receveur. Bien sûr, il peut arriver que cette représentation textuelle puisse représenter le receveur sous la forme d'une expression auto-évaluée.

\paragraph{Un mot à propos de la représentation et de la représentation auto-évaluée.}
En programmation fonctionnelle, les expressions retournent des valeurs quand elles sont évaluées. En Smalltalk, les messages (expressions) retournent des objets (valeurs). Certains objets ont la propriété sympathique d'être eux-mêmes leur propre valeur. Par exemple, la valeur de l'objet \ct{true} est lui-même, \ie l'objet \ct{true}. Nous appelons de tels objets des \emphind{objets auto-évalués}. Vous pouvez voir une version  \emph{imprimée} de la valeur d'un objet quand vous imprimez l'objet dans un \ct{Workspace}. Voici quelques exemples de telles expressions auto-évaluées. 

\begin{code}{@TEST}
true     --> true
3@4      --> 3@4
$a       --> $a
#(1 2 3) --> #(1 2 3)
\end{code}

Notez que certains objets comme les tableaux sont auto-évalués ou non suivant les objets qu'ils contiennent. Par exemple, un tableau de booléens est auto-évalué alors qu'un tableau de personnes ne l'est pas. Dans \squeak 3.9, un mécanisme a été introduit (via le message \mthind{Object}{isSelfEvaluating}) pour imprimer des collections dans leur forme auto-évaluée autant que possible et ceci est particulièrement vrai pour les tableaux dynamiques. L'exemple suivant montre qu'un tableau \subind{Array}{dynamique} est auto-évalué seulement si ses éléments le sont:
\begin{code}{@TEST}
{10@10. 100@100}          --> {10@10. 100@100}
{Browser new . 100@100}    --> an Array(a Browser 100@100)
\end{code}

Rappelez-vous que les tableaux \subind{Array}{littéraux} ne peuvent contenir que des littéraux. Ainsi le tableau suivant ne contient pas deux points mais six éléments littéraux.
\begin{code}{@TEST}
#(10@10 100@100) --> #(10 #@ 10 100 #@ 100)
\end{code}

Beaucoup de spécialisations de la méthode \ct{printOn:} implémentent le comportement d'auto-évaluation. Les implémentations de \cmind{Point}{printOn:} et \cmind{Interval}{printOn:} sont auto-évaluées.

\begin{method}[Self-evaluating points]{Auto-évaluation de \ct{Point}}
Point>>>printOn: aStream 
    "The receiver prints on aStream in terms of infix notation."
    x printOn: aStream.
    aStream nextPut: $@.
    y printOn: aStream
\end{method}\ignoredollar$

\begin{method}[Self-evaluating intervals]{Auto-évaluation de \ct{Interval}}
Interval>>>printOn: aStream
    aStream nextPut: $(;
        print: start;
        nextPutAll: ' to: ';
        print: stop.
    step ~= 1 ifTrue: [aStream nextPutAll: ' by: '; print: step].
    aStream nextPut: $)
\end{method}

\begin{code}{@TEST}
1 to: 10 --> (1 to: 10)    !"les intervals sont auto-évalués"!
\end{code}

%-----------------------------------------------------------------
\subsection{Identité et égalité}

En Smalltalk, le message \ct{=} teste l'\emphsubindmain{Object}{égualité} d'objets (\ie si deux objets représentent la même valeur) alors que \ct{==} teste l'\emphsubindmain{Object}{identité} (\ie si deux expressions représentent le même objet).
\seeindex{\ct{=}}{Object, égalité}
\seeindex{\ct{==}}{Object, identité}
\seeindex{égalité}{Object, égalité}
\seeindex{identité}{Object, identité}

L'implémentation par défaut de l'égalité entre objets teste l'identité d'objets :
\begin{method}{}
Object>>>= anObject
    "Answer whether the receiver and the argument represent the same object.
    If = is redefined in any subclass, consider also redefining the message hash."
    ^ self == anObject
\end{method}
\cmindex{Object}{=}

C'est une méthode que vous voudrez souvent surcharger. Considérez le cas de la classe des nombres complexes \ct{Complex}:

\begin{code}{@TEST}
(1 + 2 i) = (1 + 2 i)   --> true     !"même valeur"!
(1 + 2 i) == (1 + 2 i)  --> false    !"mais objets différents"!
\end{code}

Ceci fonctionne parce que \ct{Complex} surcharge \ct{=} comme suit:
\cmindex{Complex}{=}
\needlines{5}
\begin{method}{Egalité des nombres complexes}
Complex>>>= anObject
    anObject isComplex
        ifTrue: [^ (real = anObject real) & (imaginary = anObject imaginary)]
        ifFalse: [^ anObject adaptToComplex: self andSend: #=]
\end{method}

L'implémentation par défaut de \ct{Object>>>~=} renvoie simplement l'inverse de \ct{Object>>>=}, et ne devrait normalement pas être modifiée.
%\cmindex{Object}{\~=}
\index{Object!~=@\ct{~=}} % needs special treatment due to ~

\begin{code}{@TEST}
(1 + 2 i) ~= (1 + 4 i) --> true
\end{code}

Si vous surchargez \ct{=}, vous devriez envisager de surcharger \mthind{Object}{hash}. Si des instances de votre classe sont utilisées comme clés dans un dictionnaire (\clsind{Dictionary}), vous devrez alors vous assurer que les instances qui sont considérées égales ont la même valeur de hash:
\cmindex{Complex}{hash}
\begin{method}{Hash doit être ré-implémentée pour les nombres complexes}
Complex>>>hash
    "Hash is reimplemented because = is implemented."
    ^ real hash bitXor: imaginary hash.
\end{method}

Alors que vous devez surcharger à la fois \ct{=} et \ct{hash}, vous ne devriez \emph{jamais} surcharger \ct{==}. (La sémantique de l'identité d'objets est la même pour toutes les classes)  \ct{==} est une méthode primitive de \clsind{ProtoObject}.

Notez que \Squeak a certains comportements étranges comparé à d'autres Smalltalks: par exemple, un symbole et une chaîne de caractères peuvent être égaux si la chaîne de caractères associée au symbole est égale à la chaîne de caractères. (Nous considérons ce comportement comme un bug, pas comme une fonctionnalité.)

\begin{code}{@TEST}
#'lulu' = 'lulu' --> true
'lulu' = #'lulu' --> true
\end{code}


%-----------------------------------------------------------------
\subsection{Appartenance à une classe}
Plusieurs méthodes vous permettent de connaître la classe d'un objet.

\paragraph{\mthind{Object}{class}.} Vous pouvez demander à tout objet sa classe en utilisant le message \ct{class}.
\begin{code}{@TEST}
1 class --> SmallInteger
\end{code}

Inversement, vous pouvez demander si un objet est une instance d'une classe spécifique:
\cmindex{Object}{isMemberOf:}
\begin{code}{@TEST}
1 isMemberOf: SmallInteger --> true    "doit !être précisément cette classe!"
1 isMemberOf: Integer      --> false
1 isMemberOf: Number       --> false
1 isMemberOf: Object       --> false
\end{code}

Puisque \st est écrit en lui-même, vous pouvez vraiment naviguer au travers de sa structure en utilisant la bonne combinaison de messages superclass et class (voir \charef{metaclasses}). 

\paragraph{\ct{isKindOf:}}
\cmind{Object}{isKindOf:} répond \ct{true} si la classe du receveur est la même, ou bien une des sous-classes de la classe de l'argument.

\begin{code}{@TEST}
1 isKindOf: SmallInteger --> true
1 isKindOf: Integer          --> true
1 isKindOf: Number         --> true
1 isKindOf: Object           --> true
1 isKindOf: String            --> false

1/3 isKindOf: Number      --> true
1/3 isKindOf: Integer        --> false
\end{code}

\ct{1/3}, qui est une \clsind{Fraction}, est aussi une sorte de nombre (\clsind{Number}), puisque la classe \ct{Number} est une super-classe de la classe \ct{Fraction}, mais \ct{1/3} n'est pas un entier (\ct{Integer}).

\paragraph{\ct{respondsTo:}}
\cmind{Object}{respondsTo:} répond \ct{true} si le receveur comprend le message dont le sélecteur est passé en argument.

\begin{code}{@TEST}
1 respondsTo: #, --> false
\end{code}

C'est normalement une mauvaise idée de demander sa classe à un objet, ou de demander quels messages il comprend.
Au lieu de prendre des décisions basées sur la classe d'un objet, vous devriez simplement envoyer un message à cet objet et le laisser décider (\ie sur la base de sa classe) comment il doit se comporter.

%-----------------------------------------------------------------
\subsection{La copie}

Copier des objets introduit quelques problèmes subtils. Puisque les variables d'instance sont accédées par référence, une \emphsubind{Object}{copie superficielle}, les références portées par les variables d'instance devraient être partagées entre l'objet produit par la copie et l'objet original:
\seeindex{copie}{Object, \ct{copy}}
\seeindex{copie superficielle}{Object, \ct{shallowCopy}}
\seeindex{copie profonde}{Object, \ct{deepCopy}}

\begin{code}{@TEST | a1 a2 |}
a1 := { { 'harry' } }.
a1 --> #(#('harry'))
a2 := a1 shallowCopy.
a2 --> #(#('harry'))
(a1 at: 1) at: 1 put: 'sally'.
a1 --> #(#('sally'))
a2 --> #(#('sally'))    "!le tableau contenu est partagé!"
\end{code}

\cmind{Object}{shallowCopy} est une méthode primitive qui crée une copie superficielle d'un objet. Puisque \ct{a2} est seulement une copie superficielle de \ct{a1}, les deux tableaux partagent une référence au tableau (\ct{Array}) qu'ils contiennent.

\ct{Object>>>shallowCopy} est une ``interface publique'' pour \cmind{Object}{copy} et devrait être surchargé si les instances sont uniques. C'est le cas, par exemple, avec les classes \clsind{Boolean}, \clsind{Character}, \clsind{SmallInteger}, \clsind{Symbol} et \clsind{UndefinedObject}.

\cmind{Object}{copyTwoLevel} est utilisée quand une simple copie superficielle ne suffit pas:
%does the obvious thing when a simple shallow copy does not suffice:

\begin{code}{@TEST | a1 a2 |}
a1 := { { 'harry' } } .
a2 := a1 copyTwoLevel.
(a1 at: 1) at: 1 put: 'sally'.
a1 --> #(#('sally'))
a2 --> #(#('harry'))    "!état complètement indépendant!"
\end{code}

\cmind{Object}{deepCopy} effectue une copie profonde et arbitraire d'un objet.

\begin{code}{@TEST | a1 a2 |}
a1 := { { { 'harry' } } } .
a2 := a1 deepCopy.
(a1 at: 1) at: 1 put: 'sally'.
a1 --> #(#('sally'))
a2 --> #(#(#('harry')))
\end{code}

Le problème avec \ct{deepCopy} est qu'elle ne se termine pas si elle est appliquée à une structure mutuellement récursive:

\begin{code}{NB: CANNOT TEST}
a1 := { 'harry' }.
a2 := { a1 }.
a1 at: 1 put: a2.
a1 deepCopy --> !\emph{... ne se termine jamais}!
\end{code}
% NB: Not a test!

Même s'il est possible de surcharger \ct{deepCopy} pour qu'elle fonctionne mieux, \cmind{Object}{copy} offre une meilleure solution:

\begin{method}{Modèle de méthode pour la copie d'objets}
Object>>>copy
    "Answer another instance just like the receiver. Subclasses typically override postCopy;
    they typically do not override shallowCopy."
    ^self shallowCopy postCopy
\end{method}

Vous pouvez surcharger \mthind{Object}{postCopy} pour copier une variable d'instance qui ne devrait pas être partagée. \ct{postCopy} doit toujours exécuter \ct{super postCopy}.

\on{I looked, but did not finda good example in the system.}

%-----------------------------------------------------------------
\subsection{Deboguer}

La méthode la plus importante ici est \mthind{Object}{halt}. Pour placer un point d'arrêt dans une méthode, il suffit d'insérer l'envoi de message \ct{self halt} à une certaine position dans le corps de la méthode.  Quand ce message est envoyé, l'exécution est interrompue est un \ind{debogueur} s'ouvre à cet endroit de votre programme.
(Voir \charef{env} pour plus de détails sur le debogueur.)

\sd{in another chapter haltIf:, haltOnce, inspectOnce, flagging: isThisEverCalled, }

Un autre message important est \mthind{Object}{assert:}, qui prend un \ind{bloc} comme argument. Si le bloc renvoie \ct{true}, l'exécution se poursuit. Autrement une exception sera levée. Si  cette exception n'est pas attrapée, le debogueur s'ouvrira à ce point pendant l'exécution. \ct{assert:} est particulièrement utile pour la \emphind{programmation par contrat}. L'utilisation la plus typique consiste à vérifier des pré-conditions non triviales pour des méthodes publiques. \cmind{Stack}{pop} aurait pu aisément être implementée de la façon suivante:

\begin{method}{Vérifier une pré-condition}
Stack>>>pop
    "Return the first element and remove it from the stack."
    self assert: [ self isEmpty not ].
    ^self linkedList removeFirst element
\end{method}

Il ne faut pas confondre \ct{Object>>>assert:} avec \cmind{TestCase}{assert:}, méthode de l'environnement de test SUnit (voir \charef{SUnit}). Alors que la première attend un bloc en argument \footnote{En fait, elle peut prendre n'importe quel argument qui comprend \ct{value}, dont un \ct{Boolean}.}, la deuxième attend un \clsind{Boolean}. Même si les deux sont utiles pour déboguer, elles ont chacune un but très différent.

%-----------------------------------------------------------------
\subsection{Gestion des erreurs}

Ce protocole contient plusieurs méthodes utiles pour signaler les erreurs d'exécution.

Envoyer \lct{self deprecated: \emph{unChaineExplicative}} indique que la méhode courante ne devrait plus être utilisée, si le paramètre \ct{deprecation} a été activé dans le protocole \protind{debug} du browser des préférences (\ind{preference browser}).
L'argument \ct{String} devrait proposer une alternative.
\cmindex{Object}{deprecated:}
\index{déprécation}

\begin{code}{NB: CANNOT TEST}
1 doIfNotNil: [ :arg | arg printString, ' is not nil' ]
	--> !\emph{SmallInteger(Object)>>doIfNotNil: has been deprecated. use ifNotNilDo:}!
\end{code}

\ct{doesNotUnderstand:} est envoyé à chaque fois que la recherche d'un message échoue. L'implémentation par défaut, \ie \cmind{Object}{doesNotUnderstand:} déclenchera l'ouverture d'un debogueur à cet endroit. Il peut être utile de surcharger \lct{does\-Not\-Un\-der\-stand:} pour introduire un autre comportement.

\on{Add a chapter ref when we write the chapter on exceptions.}

\cmind{Object}{error} et \cmind{Object}{error:} sont des méthodes génériques qui peuvent être utilisées pour lever des exceptions.
(Il est généralement préférable de lever vos propres exceptions, pour que vous puissiez distinguer les erreurs levées par votre code de celles levées par les classes du système.)
\lr{Maybe mention that it is preferred to create your own custom exception class. (p. 208)}

Les méthodes abstraites en Smalltalk sont implémentées par convention avec le corps \lct{self sub\-class\-Res\-pon\-si\-bi\-li\-ty}. Si une classe abstraite est instanciée par accident, alors l'appel à une méthode abstraite provoquera l'évaluation de \cmind{Object}{subclassResponsibility}.

\begin{method}{Indiquer qu'une méthode est abstraite}
Object>>>subclassResponsibility
    "This message sets up a framework for the behavior of the class' subclasses.
    Announce that the subclass should have implemented this message."
    self error: 'My subclass should have overridden ', thisContext sender selector printString
\end{method}

\clsind{Magnitude}, \clsind{Number} et \clsind{Boolean} sont des exemples classiques de  classes \subind{class}{abstraites} que nous verrons rapidement dans ce chapitre.

\begin{code}{NB: CANNOT TEST}
Number new + 1 --> !\emph{Error: My subclass should have overridden \#+}!
\end{code}

\ct{self shouldNotImplement} est envoyée par convention pour signaler qu'une méthode héritée est inappropriée pour cette sous-classe. C'est généralement le signe que quelque chose ne va pas dans la conception de la hiérarchie de classes. A cause des limitations de l'héritage simple, malgré tout, il est des fois très difficile d'éviter de telles solutions.
\cmindex{Object}{shouldNotImplement}
%\apl:jenesaispastraduire\index{inheritance!canceling}

Un exemple classique est \cmind{Collection}{remove:} qui est héritée de \clsind{Dictionary} mais marquée comme non implémentée. (\ct{Dictionary} fournit la méthode \mthind{Dictionary}{removeKey:} à la place.)

%-----------------------------------------------------------------
\sd{ subsection{Deprecation} }
\sd{to be done}

\on{There already is some text above!  See second paragraph on Error handling.}

%-----------------------------------------------------------------
\subsection{Le Test}

Les méthodes de \protind{test} n'ont aucun rapport avec SUnit! Une méthode de test vous permet de poser une question sur l'état du receveur et retourne un booléen (\clsind{Boolean}).

De nombreuses méthodes de test sont fournies par \ct{Object}. Nous avons déjà vu \mthind{Object}{isComplex}. Il existe également \mthind{Object}{isArray}, \mthind{Object}{isBoolean}, \mthind{Object}{isBlock}, \mthind{Object}{isCollection}, parmi d'autres. Généralement ces méthodes sont à éviter car demander sa classe à un objet est une forme de violation de l'encapsulation. Au lieu de tester la classe d'un objet, on devrait simplement envoyer un message et laisser l'objet décider de sa propre réaction.

Cependant certaines de ces méthodes de test sont indéniablement utiles. Les plus utiles sont probablement \cmind{ProtoObject}{isNil} et \cmind{Object}{notNil} (bien que le patron de conception \patind{Null Object}\cite{Wool98a} permet d'éviter le besoin de ces méthodes également).

% \footnote{However the \emph{Null Object} design pattern can obviate the need for even these methods. See, Bobby Woolf, ``Null Object,'' Pattern Languages of Program Design 3, Robert Martin, Dirk Riehle and Frank Buschmann (Eds.), pp. 5-18, Addison Wesley, 1998.}.

%-----------------------------------------------------------------
\subsection{Initialize release}

\mthind{ProtoObject}{initialize} est une méthode clé qui ne se trouve pas dans \ct{Object} mais dans \ct{ProtoObject}.

%FIXME ``as an empty hook method``
\begin{method}{La méthode générique \lct{initialize}}
ProtoObject>>>initialize
    "Subclasses should redefine this method to perform initializations on instance creation"
\end{method}

La raison pour laquelle ceci est important est que dans la version 3.9 de \squeak, la méthode \mthind{Behavior}{new}, définie pour chaque classe du système, envoie \ct{initialize} aux instances nouvellement créées.

\begin{method}{Modèle pour la méthode de classe \lct{new}}
Behavior>>>new
    "Answer a new initialized instance of the receiver (which is a class) with no indexable
    variables. Fail if the class is indexable."
    ^ self basicNew initialize
\end{method}
\cmindex{Behavior}{new}

Ceci signifie qu'en surchargeant simplement la \ind{méthode générique} \ct{initialize}, les nouvelles instances de votre classe seront automatiquement initialisées. La méthode \ct{initialize} devrait normalement exécuter \ct{super initialize} pour établir les \subind{class}{invariants} de la classe pour toutes les variables d'instance héritées.
Notons que ceci n'est \emph{pas} le comportement standard dans les autres Smalltalks.

%=================================================================
\section{Les nombres}
\label{sec:Number}
Il faut remarquer que les nombres en Smalltalk ne sont pas des données primitives mais de vrais objets. Bien sûr les nombres sont implémentés efficacement dans la machine virtuelle, mais la hiérarchie de la classe \clsindmain{Number} est aussi accessible et extensible que n'importe quelle autre portion de la hiérarchie de classe de \st.

\begin{figure}[ht]
\centerline {\includegraphics[width=8cm]{NumberHierarchy}}
\caption{La hiérarchie de la classe Number \label{fig:numbers}}
\end{figure}

On trouve les nombres dans la catégorie \scatind{Kernel-Numbers}. La racine abstraite de cette catégorie est \clsind{Magnitude}, qui représente toutes les sortes de classes qui supportent les opérateurs de comparaison. La classe \ct{Number} ajoute plusieurs opérateurs arithmétiques et autres, principalement des méthodes abstraites. \clsind{Float} et \clsind{Fraction} représentent, respectivement, les nombres à virgule flottante et les valeurs fractionnaires.  \clsind{Integer} est également une classe abstraite, et contient trois sous-classes \clsind{SmallInteger}, \clsind{LargePositiveInteger} et \clsind{LargeNegativeInteger}. Le plus souvent les utilisateurs n'ont pas à connaître la différence entre les trois classes d'entiers, car les valeurs sont automatiquement converties si besoin est.

%-----------------------------------------------------------------
\subsection{Magnitude}

\clsindmain{Magnitude} n'est pas seulement la classe parente des classes de nombres, mais également des autres classes supportant les opérateurs de comparaison, comme \clsind{Character}, \clsind{Duration} et \clsind{Timespan}.  (Les nombres complexes (classe \clsind{Complex}) ne sont pas comparables, et n'héritent pas de la classe \clsind{Number}.)

Les méthodes \mthind{Magnitude}{<} et \mthind{Magnitude}{=} sont abstraites. Les autres opérateurs sont définis de manière générique. Par exemple :

\begin{method}{Méthodes de comparaison abstraites}
Magnitude>>> < aMagnitude 
    "Answer whether the receiver is less than the argument."
    ^self subclassResponsibility

Magnitude>>> > aMagnitude 
    "Answer whether the receiver is greater than the argument."
    ^aMagnitude < self
\end{method}
\cmindex{Magnitude}{>}

%-----------------------------------------------------------------
\subsection{Number}

De la même manière, la classe \clsindmain{Number} définit \mthind{Number}{+}, \mthind{Number}{-}, \mthind{Number}{*} et \mthind{Number}{/} comme des méthodes abstraites, mais tous les autres opérateurs arithmétiques sont définis de manière générique.

Tous les nombres supportent plusieurs opérateurs de  \emph{convertion}, comme \mthind{Number}{asFloat} et \mthind{Number}{asInteger}. Il existe également des \emphind{constructeurs} numériques,
%\emphind{shortcut constructor methods}
comme \mthind{Number}{i}, qui convertit une instance de \ct{Number} en une instance de \clsind{Complex} avec une partie réelle nulle, ainsi que d'autres méthodes qui génèrent des durées, instances de \clsind{Duration}, comme \mthind{Number}{hour}, \mthind{Number}{day} et \mthind{Number}{week}.

Les nombres supportent directement les \emph{fonctions mathématiques} telles que \mthind{Number}{sin}, \mthind{Number}{log}, \mthind{Number}{raiseTo:}, \mthind{Number}{squared}, \mthind{Number}{sqrt}.

\cmind{Number}{printOn:} utilise la méthode abstraite \ct{Number>>>printOn:base:}. (La base par défaut est 10.)

Les méthodes de test comprennent entre autres \mthind{Number}{even}, \mthind{Number}{odd}, \mthind{Number}{positive} et \mthind{Number}{negative}. Logiquement, \ct{Number} surcharge \lct{is\-Num\-ber}. Plus intéressant, \mthind{Number}{isInfinite} renvoie \ct{false}.

Les méthodes de \emph{troncature} incluent entre autres, \mthind{Number}{floor}, \mthind{Number}{ceiling}, \mthind{Number}{integerPart}, \mthind{Number}{fractionPart}.

\begin{code}{@TEST}
1 + 2.5     --> 3.5             "Addition de deux nombres"
3.4 * 5      --> 17.0           "Multiplication de deux nombres"
8 / 2         --> 4                 "Division de deux nombres"
10 - 8.3   --> 1.7              "Soustraction de deux nombres"
12 = 11    --> false           !"Egalité entre deux nombres"!
12 ~= 11 --> true            !"Teste si deux nombres sont différents"!
12 > 9      --> true            "Plus grand que"
12 >= 10  --> true            !"Plus grand ou égal à"!
12 < 10    --> false           "Plus petit que"
100@10   --> 100@10    !"Création d'un point"!
\end{code}
\on{Should check how tabbing works in the listings package ...}

L'exemple suivant fonctionne étonnamment bien en \st:
\begin{code}{@TEST}
1000 factorial / 999 factorial --> 1000
\end{code}
Notons que \ct{1000 factorial} est réellement calculé alors que dans beaucoup d'autres langages il peut être difficile de le faire. Ceci est un excellent exemple de conversion automatique et d'une gestion exacte des nombres.
\cmindex{Integer}{factorial}

\dothis{Essayez d'afficher le résultat de \ct{1000 factorial}. Il faut plus de temps pour l'afficher que pour le calculer!}

%-----------------------------------------------------------------
\subsection{Float}

\clsindmain{Float} implémente les méthodes de \ct{Number} abstraites pour les nombres à virgule flottante.

Plus intéressant, \ct{la classe Float} (\ie le côté classe de \ct{Float}) contient des méthodes pour renvoyer les \emph{constantes}: \mthind{Float class}{e}, \mthind{Float class}{infinity}, \mthind{Float class}{nan} et \mthind{Float class}{pi}.

\begin{code}{@TEST}
Float pi                      --> 3.141592653589793
Float infinity               --> Infinity
Float infinity isInfinite --> true
\end{code}

%-----------------------------------------------------------------
\subsection{Fraction}

Les \clsind{fractions} sont représentées par des variables d'instance pour le numérateur et le dénominateur, qui devraient être des entiers. Les \ct{fractions} sont normalement créées par division d'entiers (plutôt qu'en utilisant le constructeur \cmind{Fraction}{numerator:denominator:}):

\begin{code}{@TEST}
6/8             --> (3/4)
(6/8) class --> Fraction
\end{code}

Multiplier une fraction par un entier ou par une autre fraction peut renvoyer un entier :

\begin{code}{@TEST}
6/8 * 4 --> 3
\end{code}

\lr{Maybe mention to avoid fractions in results that one of the operands has to be a float, e.g. 6.0 / 8 or 6 asFloat / 8. (p. 213)}

%-----------------------------------------------------------------
\subsection{Integer}

\clsindmain{Integer} est le parent abstrait de trois implémentations concrètes d'entiers. En plus de fournir une implémentation concrète de beaucoup de méthodes abstraites de la classe \ct{Number}, il ajoute également quelques méthodes spécifiques aux entiers, telles que \mthind{Integer}{factorial}, \mthind{Integer}{atRandom}, \mthind{Integer}{isPrime}, \mthind{Integer}{gcd:} et beaucoup d'autres.

\clsindmain{SmallInteger} est particulière dans le sens que ses instances sont représentées de manière compacte --- au lieu d'être stockées comme référence, une instance de \ct{SmallInteger} est directement représentée en utilisant les bits qui seraient normalement utilisés pour contenir la référence.  Le premier bit de la référence à un objet indique si l'objet est une instance de SmallInteger ou non.

Les méthodes de classe \mthind{SmallInteger}{minVal} et \mthind{SmallInteger}{maxVal} nous donne la plage de valeurs d'une instance de \ct{SmallInteger}:

\begin{code}{@TEST}
SmallInteger maxVal = ((2 raisedTo: 30) - 1)      --> true
SmallInteger minVal = (2 raisedTo: 30) negated --> true
\end{code}

Quand un \ct{SmallInteger} dépasse cette plage de valeurs, il est automatiquement converti en une instance de \clsind{LargePositiveInteger} ou de \clsind{LargeNegativeInteger}, selon le besoin:

\begin{code}{@TEST}
(SmallInteger maxVal + 1) class --> LargePositiveInteger
(SmallInteger minVal - 1) class  --> LargeNegativeInteger
\end{code}

Les grands entiers sont de la même manière convertis en petits entiers quand il faut.

Comme dans la plupart des langages de programmation, les entiers peuvent être utiles pour spécifier une itération.  Il existe une méthode dédiée \mthind{Integer}{timesRepeat:} pour l'évaluation répétitive d'un bloc.
Nous avons déjà vu des exemples similaires dans le chapitre \charef{syntax}:
\begin{code}{@TEST | n |}
n := 2.
3 timesRepeat: [ n := n*n ].
n --> 256
\end{code}

%=================================================================
\section{Les Caractères}

\clsindmain{Character} est définie dans la catégorie \scatind{Collections-Strings} comme une sous-classe de \clsind{Magnitude}. Les caractères imprimables sont représentés en \squeak par \lct{\$$\langle$\emph{char}$\rangle$}.  Par exemple:

\begin{code}{@TEST}
$a < $b --> true
\end{code}

Les caractères non imprimables sont générés par différentes méthodes de classe. \mbox{\cmind{Character class}{value:}} prend la valeur entière Unicode (or ASCII) comme argument et renvoie le caractère correspondant. Le protocole \protind{accessing untypeable characters} contient un certain nombre de constructeurs utiles tels que \mthind{Character class}{backspace}, \mthind{Character class}{cr}, \mthind{Character class}{escape}, \mthind{Character class}{euro}, \mthind{Character class}{space}, \mthind{Character class}{tab}, parmi d'autres.

\begin{code}{@TEST}
Character space = (Character value: Character space asciiValue) --> true
\end{code}

La méthode \mthind{Character}{printOn:} est assez adroite pour savoir laquelle des trois manière utiliser pour générer les caractères de la manière la plus appropriée :

\begin{code}{@TEST}
Character value: 1   --> Character value: 1
Character value: 32 --> Character space
Character value: 97 --> $a
\end{code}\ignoredollar$

Il existe plusieurs méthodes de \emph{test} utiles : \mthind{Character}{isAlphaNumeric}, \mthind{Character}{isCharacter}, \mthind{Character}{isDigit}, \mthind{Character}{isLowercase}, \mthind{Character}{isVowel}, parmi d'autres.

Pour convertir un caractère en une chaîne de caractères contenant uniquement ce caractère, il faut lui envoyer le message \mthind{Character}{asString}.  Dans ce cas \ct{asString} et \mthind{Character}{printString} donnent des résultats différents:

\begin{code}{@TEST}
$a asString    --> 'a'
$a                  --> $a
$a printString --> '$a'
\end{code}\ignoredollar$

Chaque caractère ASCII est une instance unique, stockée dans la variable de classe \cvind{CharacterTable}:

\begin{code}{@TEST}
(Character value: 97) == $a --> true
\end{code}\ignoredollar$

Cependant, les caractères au delà de la plage 0 à 255 ne sont pas uniques: 
\begin{code}{@TEST}
Character characterTable size                               --> 256
(Character value: 500) == (Character value: 500) --> false
\end{code}

%=================================================================
\section{Les chaînes de caractères}

La classe \clsindmain{String} est également définie dans la catégorie \scatind{Collections-Strings}.  Une chaîne de caractères est une collection indexée contenant uniquement des caractères.

\begin{figure}[ht]
\ifluluelse
	{\centerline {\includegraphics[width=0.5\textwidth]{StringHierarchy}}}
	{\centerline {\includegraphics[width=6cm]{StringHierarchy}}}
\caption{La hiérarchie de String \label{fig:strings}}
\end{figure}

En fait, \ct{String} est une classe abstraite les chaînes de caractères de \squeak sont en réalité des instances de la classe concrète \clsindmain{ByteString}.

\begin{code}{@TEST}
'hello world' class --> ByteString
\end{code}

Une autre sous-classe importante de \ct{String} est \clsindmain{Symbol}.  La différence fondamentale est qu'il n'y a toujours qu'une instance unique de \ct{Symbol} pour une valeur donnée.  (Ceci est quelques fois appelé ``la propriété de l'instance unique'').  A l'opposé, deux chaînes construites séparément  qui contiennent la même séquence de caractères seront souvent des objets différents.

\begin{code}{@TEST}
'hel','lo' == 'hello' --> false
\end{code}

\begin{code}{@TEST}
('hel','lo') asSymbol == #hello --> true
\end{code}

\noindent
Une autre différence importante est que \ct{String} est mutable, alors que \ct{Symbol} est immuable.

\begin{code}{@TEST}
'hello' at: 2 put: $u; yourself --> 'hullo'
\end{code}\ignoredollar$

\begin{code}{NB: CANNOT TEST}
#hello at: 2 put: $u --> error!
\end{code}\ignoredollar$

Il est facile d'oublier que puisque les chaînes de caractères sont des collections; elles comprennent les mêmes messages que les autres collections: 

\begin{code}{@TEST}
#hello indexOf: $o --> 5
\end{code}\ignoredollar$

Bien que \ct{String} n'hérite pas de \clsind{Magnitude}, la classe supporte les méthodes de  \protind{comparaison}, \ct{<}, \ct{=}, etc.  De plus, \cmind{String}{match:} est utile pour les recherches simples d'expressions régulières:

\begin{code}{@TEST}
'*or*' match: 'zorro' --> true
\end{code}

Si vous avez besoin d'un meilleur support pour les expressions régulières, plusieurs implémentations sont disponibles, comme le paquet  Regex de  Vassili Bykov.
\index{Bykov, Vassili}
\index{Package pour les expressions régulières}

Les chaînes de caractères supportent un grand nombre de méthodes de conversion. Beaucoup sont des \ind{Constructeurs} pour d'autres classes, comme \mthind{String}{asDate}, \mthind{String}{asFileName}.  Il existe également un certain nombre de méthodes utiles pour transformation d'une chaîne de caractères en une autre, comme \mthind{String}{capitalized} et \mthind{String}{translateToLowercase}.

Pour plus d'informations sur les chaînes de caractères et les collections, voir le chapitre \charef{collections}.

\on{There is more material we could use here:
\url{http://www.dmu.com/crb/crb7.html}.}

%=================================================================
\section{Les booléens}

La classe \clsindmain{Boolean} offre un aperçu fascinant de la manière dont \st est construit autour de la librairie de classe. 
%how much of the Smalltalk language has been pushed into the class library. 
\ct{Boolean} est la super-classe \subind{class}{abstraite} des classes singleton \patind{Singleton} \clsindmain{True} et \clsindmain{False}.

\begin{figure}[ht]
\ifluluelse
	{\centerline {\includegraphics[width=0.6\textwidth]{BooleanHierarchy}}}
	{\centerline {\includegraphics[width=6cm]{BooleanHierarchy}}}
\caption{La hiérarchie des booléens \label{fig:booleans}}
\end{figure}

La plupart des comportements des booléens peuvent être compris en regardant la méthode \mthind{Boolean}{ifTrue:ifFalse:}, qui prend deux blocs comme arguments.

\begin{code}{@TEST}
(4 factorial > 20) ifTrue: [ 'bigger' ] ifFalse: [ 'smaller' ] --> 'bigger'
\end{code}

La méthode est abstraite dans \ct{Boolean}.
Les implémentations dans les sous-classes concrètes sont toutes les deux triviales:

\begin{method}{Implementations de \lct{ifTrue:ifFalse:}}
True>>>ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 
    ^trueAlternativeBlock value

False>>>ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 
    ^falseAlternativeBlock value
\end{method}
\cmindex{True}{ifTrue:}
\cmindex{False}{ifTrue:}

En fait, ceci est l'essence même de la POO: quand un message est envoyé à un objet, l'objet lui-même détermine quelle méthode sera utilisée pour répondre. Dans ce cas une instance de \ct{True}  évalue simplement l'alternative \emph{true}, alors qu'une instance de \ct{False} evalue l'alternative \emph{false}.  Toutes les méthodes abstraites de la classe \ct{Boolean} sont implémentées de cette manière pour \ct{True} et \ct{False}. Par exemple:

\begin{method}{Implémenter la négation}
True>>>not
    "Negation--answer false since the receiver is true."
    ^false
\end{method}
\cmindex{True}{not}

La classe \ct{Boolean} offre plusieurs méthodes utiles, comme \mthind{Boolean}{ifTrue:}, \mthind{Boolean}{ifFalse:}, \mthind{Boolean}{ifFalse:ifTrue}. Vous avez également le choix entre les conjonctions et disjonctions optimisées ou paresseuses.

\begin{code}{@TEST}
(1>2) & (3<4)              --> false    !"doit évaluer les deux cotés"!
(1>2) and: [ 3<4 ]        --> false    !"évalue seulement le receveur"!
(1>2) and: [ (1/0) > 0 ] --> false    !"le bloc passé en argument n'est jamais évalué, ainsi, pas d'exception"!
\end{code}

Dans le premier exemple, les deux sous-expressions booléennes sont évaluées, puisque \mthind{Boolean}{&} prend un argument booléen.
Dans le second et troisième exemple, uniquement la première est évaluée, car \mthind{Boolean}{and:} attend un  bloc comme argument. Le  bloc est évalué uniquement si le premier argument vaut \pvind{true}.

\dothis{Essayez d'imaginer comment \ct{and:} et \ct{or:} sont implémentés.
Vérifiez les implémentations dans \ct{Boolean}, \ct{True} et \ct{False}.}

%=================================================================
\section{Résumé du chapitre}

\begin{itemize}
%  \item Send \ct{yourself} to get back the receiver at the end of a cascade.

  \item Si vous surchargez \ct{=} alors vous devez également surcharger \ct{hash}.

  \item Surchargez \ct{postCopy} pour implémenter correctement la copie de vos objets.

  \item Envoyez \ct{self halt} pour créer un point d'arrêt.

  \item Renvoyez \ct{self subclassResponsibility} pour faire une méthode abstraite.

  \item Pour donner la représentation en chaîne de caractères d'un objet \ct{String} vous devez surcharger \ct{printOn:}.

  \item Surchargez la méthode générique \ct{initialize} pour instancier correctement vos objets.

  \item Les méthodes de la classe \ct{Number} convertissent automatiquement entre flottants, fractions et entiers.

  \item Les fractions représentent vraiment des nombres réels plutôt que des nombres à virgule flottante.

  \item Les caractères sont des instances uniques.

  \item Les chaînes de caractères sont mutables, les symboles ne le sont pas.
  Cependant faites attention à ne pas muter les chaînes de caractères littérales!

  \item Les symboles sont uniques, les chaînes de caractères ne le sont pas.

  \item Les chaînes de caractères et les symboles sont des collections et donc supportent les méthodes usuelles de la classe \ct{Collection}.

\end{itemize}

%=============================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=============================================================

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:
